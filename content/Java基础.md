### 1. wait, sleep区别

1. `wait()`方法属于java.lang.Object, `sleep()`属于java.lang.Thread
2. `wait()`表示等待在一个对象上线,需要获得这个对象的锁,否则抛出`IllegalMonitorStateException`
3. 调用 `wait()`会自动释放获取到的锁,`sleep()`方法不会
4. 线程状态:`wait()`的线程状态为 WAITING,`sleep()` 为TIMED_WAITING



### 2. wait, sleep 区别,调用 wait 方法后,如何唤醒线程

1. 区别略
2. 如何唤醒调用 `wait()`方法的线程
   1.  `wait()`的原理:这个方法需要获取对象的锁, 及`ObjectMonitor` 对象, 这个对象中维护了`_WaitSet` 和`_EntryList`, `wait()`方法就是把当前线程放入`_ WaitSet` 队列中, 再调用` park()`, 挂起当前线程. 最后释放这个锁
   2. 如何唤醒:就是在该对象上调用` notify()` 方法,该方法会在`_ WaitSet` 中随机选取一个线程 放入`_ EntryList` 中,就唤醒了这个线程



### 3. volatile关键字怎么保证可见性

#### 3.1 明确什么是可见性

可见性是指对一个在堆上的变量的修改,每个线程都能看到这个变量的最新的值.

#### 3.2 为什么会出现可见性问题

java 因为跨平台,抽象了一套属于自己的内存模型.存在一个主内存和每个线程都拥有的本地内存.

程序是不能直接访问主内存的,对一个变量的修改,需要将其copy 到本地内存,再修改后刷新会主内存,才完成了对这个变量的修改.如果此时一个线程对变量进行了修改,另外一个线程是看不见这个修改的

#### 3.3 如何保证

volatile 修饰的变量,会建立一个 happen-before 关系.及对于一个 volatile 变量的写 hb 与一个 volatile 变量的写.

volatile 是通过插入内存屏障与禁止指令重排序来保证 volatile 变量的可见性的.

读操作之前插入 loadload 屏障,读操作之后插入 loadstore 屏障

写操作之前插入 storestore 屏障,写操作之后插入storeload 屏障

再底层原理,在x86 架构上,编译成的本地代码,对这些变量的操作,会插入一个 lock 指令.涉及到缓存一致性协议了~


### 4. long类型的操作是原子性吗？为什么？

要分情况讨论，对于64位的系统来说是的，对于32位的系统来说不是，为什么呢？

因为对于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变量”的数值，即64位数据被两个线程分成了两次读取。



### 5. String 为什么 final 修饰

> 也就是问String 这个类为什么要设计成不可变的

1.字符串常量池

jvm 存在字符串常量池,创建一个字符串,如果常量池中已经存在,会直接返回这个字符串的引用.如果能随意修改String 的值(修改常量池中的字符串),会出现问题

2.安全性

java 中大量使用String 字符串作为一个参数,比如` Socket socket = new Socket(host, port)`,如果 String 可修改,我们 会认为连接到某台机器,但实际上并没有

3.不可变对象带来的线程安全性

不可变对象天生就是线程安全的,避免锁操作,带来性能上的优势



### 6. java 为什么不支持多继承

多继承会带来菱形问题.存在一个抽象类 A, 有方法` foo()`, B,C 继承 A并且实现了各自的` foo()` 方法.如果允许多继承, D 继承 B,C 两个类,那么此时D 的` foo()` 存在歧义

