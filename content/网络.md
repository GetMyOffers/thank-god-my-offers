### 1.讲讲网络层次划分

> 这么问，应该确认下面试想问的是七层模型还是五层模型

1. 七层模型

   应用层 协议层 会话层 运输层 网络层 数据链路层 物理层

2. 五层模型

   应用层 运输层 网络层 数据链路层 物理层

### 2.谈谈udp，tcp区别
> 提三次握手，四次挥手，引导下面试官
1. 面向连接：tcp是面向连接的，需要先建立连接，再发送数据(提三次握手，四次挥手)，udp不需要
2. 可靠数据传输：tcp提供有序，无差错，不丢失，不重复的可靠数据传输服务，通过ack，定时器，重传机制保证。udp不提供可靠传输
3. 面向流的传输和面向报文的传输：tcp面向字节流传输，会将数据分成多个组，udp没有分组开销

### 3.谈谈三次握手，四次挥手
> 这个问题，不能简单谈谈，对于状态转移应该一并回答
```
           |                      |
           | syn=1,seq=x          |
syn_send   |--------------------->|  syn_rcvd
           |                      |
           |                      |
           |                      |
           | syn=1,ack=x+1,seq=y  |          
established|<---------------------|
           |                      |
           |                      |
           | syn=0,ack=y+1,seq=x+1|
           |--------------------->|   establshed
           |                      |
           |                      |
           
           
           |                      |
           |    fin=1             |
fin_wait_1 |--------------------->|  close_wait
           |                      |
           |                      |
           |     ack              |          
fin_wait_2 |<---------------------|   
           |                      |
           |                      |
           |      fin=1           |
time_wait  |<---------------------|  last_ack
           |      ack             |
           |--------------------->|  closed         
```

### 4.为什么需要三次握手，四次挥手
采⽤用三次握⼿手是为了了防⽌止失效的连接请求报 ⽂文段突然⼜又传送到主机B，因⽽而产⽣生错误。失效的 连接请求报⽂文段是指:主机A发出的连接请求没有 收到主机B的确认，于是经过⼀一段时间后，主机A⼜又 重新向主机B发送连接请求，且建⽴立成功，顺序完 成数据传输。考虑这样⼀一种特殊情况，主机A第⼀一 次发送的连接请求并没有丢失，⽽而是因为⽹网络节点 导致延迟达到主机B，主机B以为是主机A⼜又发起的 新连接，于是主机B同意连接，并向主机A发回确 认，但是此时主机A根本不不会理理会，主机B就⼀一直在等待主机A发送数据，导致主机B的资源浪费。



在TCP连接中，服务器器端的SYN和ACK向客户端发送 是⼀一次性发送的，⽽而在断开连接的过程中，B端向A 端发送的ACK和FIN是是分两次发送的。因为在B端 接收到A端的FIN后，B端可能还有数据要传输，所 以先发送ACK，等B端处理理完⾃自⼰己的事情后就可以发 送FIN断开连接了了。



### 5.如果服务端存在大量close_wait状态，大量time_wait状态
close_wait的产生，是因为被动关闭tcp连接，收到了一个fin包，但是没有没有回ack包，造成服务端大量close_wait状态，大概率是处理这个连接的线程block住了

time_wait状态过多，是服务端主动关闭连接，客户端没有及时回fin包导致，或者因为我们需要等2MSL时间，出现这种情况，我们应该修改修改内核参数。

### 6.time_wait为什么需要等2MSL，才会关闭
> MSL-Maximum Segment Lifetime，最大报文生产周期

* 可靠地实现TCP全双工连接的终止

假设上一节TCP连接分组交换中的最后一个ACK丢失了。服务器将重新发送他的最终的那个FIN，因此客户必须维护状态信息，以允许他重新发送最终那个ACK。客户如果不维护状态信息，它将响应一个RST，该分节被服务器解释成一个错误。如果要全双工关闭（执行所有必要的工作以彻底终止某个连接上两个方向的数据流），那么连接终止序列四个分节中的任何一个分节丢失的情况都得正确处理。

* 允许老的重复分节在网络中消逝

假设一个套接字对之间建立了一个连接，我们关闭该连接后在相同的套接字对又建立了一个连接。后一个连接成为前一个的化身，TCP必须防止来自某个连接的老的重复分组在该连接已经终止后再现。为了不接受老的分组，TCP将不给处于TIME_WAIT状态的连接发起新的化身。TIME_WAIT状态持续时间为2MSL这就足以让某个方向上的分组最多存活MSL即被丢弃，另一个方向上的应答也最多存活MSL秒被丢弃。



### 7.那close_wait，time_wait过多又会产生什么问题
占用连接数，造成服务拒绝连接。

### 8.短时间内有大量的短连接建立，比如10w个连接，会出什么问题
主要是短，这个问题不考虑连接复用之类的技术，认为是服务端主动关闭连接，主要考虑time_wait的问题。那么就同上了


### 9.访问xxx的全过程
> 这个问题有点模糊，面试java后端开发，需不需要讲讲请求的处理过程，比如springMVC是如何处理请求的？
1. dns解析
   浏览器缓存
   操作系统缓存
   请求ldns
   请求ldns，无返回结果，会向root server请求，返回一个所查询域的主域名服务器(g tld server)
   ldns请求 g tld server, 返回此域名对应的name server
   请求name server，获取ip
   ldns缓存结果，并将结果返回给用户
   dns解析完成
2. http请求，tcp连接的建立
3. 发送请求报文
   讲讲请求结构?
4. 获取到响应报文
   讲讲响应结构?
5. 解析，加载js，渲染页面

### 10. 反向代理,负载均衡解释下



![反向代理](https://ws1.sinaimg.cn/large/0069RVTdgy1ftudnx5jn1j30vb08fmxu.jpg)

* 所谓反向代理就是通过一个 nginx 隐藏后端服务,请求打到 nginx 上后, nginx 再将请求转发到后端服务
* 在此基础上,一个服务存在多个实例,我们需要选择请求打到某个实例上,就是利用 nginx 做负载均衡了
  * 平均轮询法
  * 加权轮询法
  * 随机法
  * 加权随机法
  * 最小连接数
  * 源地址 hash














