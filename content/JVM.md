
### 1. 讲一下Java内存划分

Java虚拟机在运行程序时会把其自动管理的内存划分为以下几个区域：
- 堆内存：所有线程共享，对象实例。当扩展内存大于可用内存，抛OOM。
- 方法区：已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。当内存申请大于实际可用内存，抛OOM。
- 程序计数器：是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。是Java虚拟机规范中唯一没有规定OOM（OutOfMemoryError）的区域。
- Java虚拟机栈：也是线程私有的，它的生命周期与线程相同。执行java方法。若线程请求深度大于栈的深度，抛StackOverflowError。若栈在动态扩展时无法请求足够内存，抛OOM。
- 本地方法栈：与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。也会抛StackOverflowError和OOM。

JMM会对每个线程分配一个区域（包括程序计数器、虚拟机栈、本地方法栈）用于存储线程私有的数据。其余数据存储在 JVM堆 及 方法区。

![](https://github.com/Lisanaaa/thank-god-my-offers/blob/master/images/3191532947647_.pic_hd.jpg)
![](https://github.com/Lisanaaa/thank-god-my-offers/blob/master/images/3201532947704_.pic_hd.jpg)
堆内存里面分为老年代和新生代，其中新生代中分为 Eden 区，from survivor 区和 to survivor 区

### 2. 有哪些垃圾收集算法

- 引用计数法（无法解决循环引用的问题，不被java采纳）
- 根搜索算法
- 现代虚拟机中的垃圾搜集算法：
    - 标记-清除
    - 复制算法（新生代）
    - 标记-压缩（老年代）
- 分代收集法

### 3. 哪些对象可以作为GC Roots？

- 虚拟机栈（栈帧中的本地变量表）中的引用的对象
- 方法区中的类静态属性引用的对象
- 方法区中的常量引用的对象
- 本地方法栈中JNI（Native方法）的引用对象

### 4. GC是在什么时候，对什么东西，做了什么事情？

**什么时候**

- Minor GC触发条件：当Eden区满时，触发Minor GC。

- Full GC触发条件：
    - （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
    - （2）老年代空间不足
    - （3）方法去空间不足
    - （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
    - （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

**什么东西**

从gc root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。

**做了什么**

最浅显的理解为释放对象。但是从 GC 的底层机制可以看出，对于可以搜索到的对象是进行复制操作，对于搜索不到的对象，调用finalize()方法进行释放。

具体过程：当GC线程启动时，会通过可达性分析法把 Eden 区和 From survivor 区的存活对象复制到 To survivor 区，然后把 Eden survivor 和From survivor 区的对象释放掉。当 GC 轮循扫描 To survivor 区一定次数后，把依然存活的对象复制到老年代，然后释放 To survivor 区的对象。

对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。

- 第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。
- 第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。

### 5. 为什么要分两个 Survivor？

之所以要分两个 Survivor，而不是直接从 Survivor 直接移到 老年代区域，原因是老年代区域内的对象都是经过若干次 GC 过程之后存活下来的对象，并不是每一次 GC 存活下来的对象都需要移动到老年代区域内的，所以需要 from Survivor 区和 to Survivor区来保证 新生代 内存中的复制算法的实行，提高清除效率。

### 6. JVM 的 happens-before 原则是什么？

1. 程序顺序原则：一个线程内必须保证语义串行性,按照代码顺序执行
2. 锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前
3. volatile规则：volatile变量的写，先发生于读
4. 线程启动规则：线程的start()方法先于它的每一个动作
5. 传递性:A先于B ，B先于C 那么A必然先于C
6. 线程终止规则:线程的所有操作先于线程的终结对线程 线程中断规则:interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. 对象终结规则:对象的构造函数执行，结束先于finalize()方法

### 7. 讲到JMM应该还会提到对应的原子性、有序性、可见性以及volatile关键字

就请去多线程那边看吧！








