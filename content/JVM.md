
### 讲一下Java内存模型，happens-before 原则。

> 感觉面试官这样问一般好像要答一答Java内存区域的划分~~~

Java虚拟机在运行程序时会把其自动管理的内存划分为以下几个区域：

- **元空间**：线程共享、存储class信息。

- **JVM堆**（Java Heap）：线程共享、存放new出来的数组和对象数据、类的静态变量、包含常量池

- **程序计数器**(Program Counter Register)：生命周期同线程、用以完成分支、循环、跳转、异常处理、线程恢复等基础功能

- **虚拟机栈**(Java Virtual Machine Stacks)：生命周期同线程、每个方法在调用时都会在虚拟机栈中创建一个方法帧，方法帧中包含了局部变量，参数，运行中间结果等信息

- **本地方法栈**(Native Method Stacks)：：生命周期同线程、存放的是native方法帧。

Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，**通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式**。

JMM会对每个线程分配一个区域（包括程序计数器、虚拟机栈、本地方法栈）用于存储线程私有的数据。其余数据存储在 JVM堆 及 元空间。

> 讲到JMM应该还会提到对应的 原子性、有序性、可见性以及volatile关键字

原子性指的是一个操作是原子不可分割的，不可中断。
（long类型的操作是原子性吗？为什么？）

可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。

有序性是指对于**单线程**的执行代码，是按顺序依次执行。但是多线程会出现**指令重排**。
但是JMM还有happens-before 原则：
1. 程序顺序原则：一个线程内必须保证语义串行性,按照代码顺序执行
1. 锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前
1. volatile规则：volatile变量的写，先发生于读
1. 线程启动规则：线程的start()方法先于它的每一个动作
1. 传递性:A先于B ，B先于C 那么A必然先于C
1. 线程终止规则:线程的所有操作先于线程的终结对线程 线程中断规则:interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
1. 对象终结规则:对象的构造函数执行，结束先于finalize()方法

volatile能保证被修饰的共享变量对所有线程**总是可见的**。**禁止指令重排序优化**

> 最好回答的时候能够边画图，第一方便记忆理解，第二能让面试官更加容易知道你在说什么。
