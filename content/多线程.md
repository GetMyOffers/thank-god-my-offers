### 1. 说一下 volatile 关键字和指令重排序的关系

**为什么要重排序**

一个指令的执行被分成：取指、译码、访存、执行、写回、等若干个阶段。然后，多条指令可以同时存在于流水线中，同时被执行。重排序的目的是为了性能。

**as-if-serial**

as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。

如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。分为下面三种情况：

名称	| 示例 | 说明
写后读|	a = 1; b = a;	|写一个变量后再读这个位置
写后写|	a = 1; a = 2;	|写一个变量后再写这个变量
读后写|	a = b; b = 1;	|读一个变量后再写这个变量

上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。所以有数据依赖性的语句不能进行重排序

**volatile 关键字**

volatile 有两层含义：
1. 保证了不同线程对这个变量进行操作时的**可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

Example:
```java
// 线程1
boolean stop = false;
while(!stop){
    doSomething();
}
// 线程2
stop = true;
```

先看这段代码会完全运行正确么？即一定会将线程中断么？
答案是：不一定！

线程1在运行的时候，会将 stop 变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了 stop 变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对 stop 变量的更改，因此还会一直循环下去。

如果加上 volatile 则不一样：

- 使用 volatile 关键字会强制将修改的值立即写入主存。
- 使用 volatile 关键字的话，当线程2已经对变量在主存进行修改时，会导致线程1的工作内存中缓存变量 stop 的缓存行无效。（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）
- 由于线程1的工作内存中缓存变量 stop 的缓存行无效，所以线程1再次读取变量 stop 的值时会去主存读取。

2. 禁止进行指令重排序。

当程序执行到 volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。
Example:
```java
//x、y为非volatile变量
//flag为volatile变量

x = 2;         //语句1
y = 0;         //语句2
flag = true;   //语句3
x = 4;         //语句4
y = -1;        //语句5
```
由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。

并且 volatile 关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。

**volatile 能保证原子性吗**

不能，为什么呢，举个例子，循环自增操作，关键在于自增操作不是原子的。自增操作分为3步：

- 读取变量的原始值
- 进行加1操作，这时候还是在自己工作内存中
- 写入工作内存

i++实际为load、Increment、store三个操作。

以volatile int i = 10；i++；为例分析：某一时刻线程1将i的值load取出来，放置到cpu缓存中，然后再将此值放置到寄存器A中，然后A中的值自增1（寄存器A中保存的是中间值，没有直接修改i，因此其他线程并不会获取到这个自增1的值）。如果在此时线程2也执行同样的操作，获取值i==10,自增1变为11，然后马上刷入主内存。此时由于线程2修改了i的值，实时的线程1中的i==10的值缓存失效，重新从主内存中读取，变为11。接下来线程1恢复。将自增过后的A寄存器值11赋值给cpu缓存i。这样就出现了线程安全问题。这里的线程安全问题指的是线程1的结果不如它的预期了。

加深一下对原子性的理解，请分析以下哪些操作是原子性操作：
```java
x = 10;         //语句1
y = x;         //语句2
x++;           //语句3
x = x + 1;     //语句4
```
乍一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。

- 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。
- 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的- 值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
- 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

所以上面4个语句只有语句1的操作具备原子性。

**可以用volatile的地方**

对一个变量，更新其值的时候不依赖于当前值，且该变量不会和其他一起构成一个不可变条件

### 2. 多线程的好处及线程的创建方式

好处：

1.	解决了一个进程里面可以同时运行多个任务（执行路径）。
2.	提供资源的利用率，而不是提供效率。

弊端:

1.	降低了一个进程里面的线程的执行频率。
2.	对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。
3.	公有变量的同时读或写。当多个线程需要对公有变量进行写操作时,后一个线程往往会修改掉前一个线程存放的数据，发生线程安全问题。
4.	线程的死锁。即较长时间的等待或资源竞争以及死锁等多线程症状。

方式一：继承Thread类，重写run方法。      SaleTickets thread = new SaleTickets();

1.	线程的启动使用父类的start()方法
2.	如果线程对象直接调用run()，那么JVM不会当作线程来运行，会认为是普通的方法调用

方式二：实现Runnable接口，重写run方法.    SaleTickets thread = new SaleTickets();
                                       Thread true_thread = new Thread(thread);

为什么要将Runnable接口的子类对象传递给Thread的构造函数，因为自定义的run方法所属对象是Runnable接口的子类对象，所以要让线程去执行指定对象的run方法

推荐使用： 第二种。实现Runable接口的。原因： 因为java单继承 ,多实现的。

### 3.Java线程池
通常用Executors 的一些静态方法生成例如：
- newFixedThreadPool
- newWorkStealingPool
- newFixedThreadPool
- newSingleThreadExecutor
- newCachedThreadPool
- newScheduledThreadPool

能从命名看出各个线程池的特点，
其实这些线程池都调用了

```
ThreadPoolExecutor（int corePoolSize,int maximumPoolSize,
                long keepAliveTime,TimeUnit unit,
                BlockingQueue<Runnable> workQueue，
                ThreadFactory threadFactory，
                RejectedExecutionHandler handler）
```
  
理解这几个参数 ： 
- corePoolSize  字段表示的是线程池中一直存活着的核心线程的最小数量
- maximumPoolSize 表示线程池内能够容纳线程数量的最大值. 
- keepAliveTime 表示**超出核心线程数的空闲线程**处于等待状态的超时时间(等待时间的上限值, 超过该时间后该线程会停止工作)
-  workQueue 是一个 BlockingQueue(阻塞队列) 的实例
- threadFactory 线程工厂, 用于创建线程. 
- handle 拒绝策略，在以下情况调用
1. 当线程池处于 SHUTDOWN (关闭) 状态时(不论线程池和阻塞队列是否都已满) 
1. 当线程池中的所有线程都处于运行状态并且线程池中的阻塞队列已满时

线程池拒绝策略

1. 直接丢弃（DiscardPolicy）
1. 丢弃队列中最老的任务(DiscardOldestPolicy)。
1. 抛异常(AbortPolicy)（默认）
1. 将任务分给调用线程来执行(CallerRunsPolicy)。

线程池状态：
1. RUNNING (运行状态): 能接受新提交的任务, 并且也能处理阻塞队列中的任务. 
1. SHUTDOWN (关闭状态): 不再接受新提交的任务, 但却可以继续处理阻塞队列中已保存的任务. 在线程池处于 RUNNING 状态时, 调用 shutdown()方法会使线程池进入到该状态. 当然, finalize() 方法在执行过程中或许也会隐式地进入该状态. 
1. STOP : 不能接受新提交的任务, 也不能处理阻塞队列中已保存的任务, 并且会中断正在处理中的任务. 在线程池处于 RUNNING 或 SHUTDOWN 状态时, 调用 shutdownNow() 方法会使线程池进入到该状态. 
1. TIDYING (清理状态): 所有的任务都已终止了, workerCount (有效线程数) 为0, 线程池进入该状态后会调用 terminated() 方法以让该线程池进入TERMINATED 状态. 当线程池处于 SHUTDOWN 状态时, 如果此后线程池内没有线程了并且阻塞队列内也没有待执行的任务了 (即: 二者都为空), 线程池就会进入到该状态. 当线程池处于 STOP 状态时, 如果此后线程池内没有线程了, 线程池就会进入到该状态. 
1. TERMINATED : terminated() 方法执行完后就进入该状态.


线程池参数参考策略：　　
一般需要根据任务的类型来配置线程池大小：
　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1
　　如果是IO密集型任务，参考值可以设置为2*NCPU

### 4.为什么程序要多线程而不是多进程
首先先答二者的区别：
- 一个进程可以有一个或多个线程。
- 线程可以共享内存，进程执行拥有独立的内存系统。（进程通信看操作系统）
- 线程是CPU调度的基本单位，CPU不直接调度进程，是执行对应进程的线程。
- 进程是资源分配的基本单位，一个进程下的线程都可以共享进程的资源。

为何多线程：
- 多线程可以共享内存与资源，通信方便（要考虑线程安全）。
- 进程有自己独立的内存和资源，不易共享和通信。
- 创建进程开销大，而进程较小，协程更小~


一个比喻帮助理解：
> 单进程单线程：一个人在一个桌子上吃菜。  
单进程多线程：多个人在同一个桌子上一起吃菜。  
多进程单线程：多个人每个人在自己的桌子上吃菜。   

## References
1. [Java中的重排序和 volatile 关键字](https://www.jianshu.com/p/b4d4506d3585)
